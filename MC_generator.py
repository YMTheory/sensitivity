import numpy as np
from scipy.integrate import dblquad
from histlite import hist

from signal_spectrum import signal_calculation
from detector import detector
from neutrino_source import neutrino_source
from oscillation import *
from xsection import xsection

from unit_conversion import *

class MC_generator:
    def __init__(self, source, det, dm2=1.0, sin2theta_square=0.1, int_type='nue'):
        self.source = source
        self.det = det
        self.xsec = xsection()
        self.interaction =  int_type # 'nue' or CC, only two options now
        
        #### calculate baseline ranges:
        self.baseline_min = np.abs(self.det.position[2] - self.source.position[2]) - self.det.height/2.
        self.baseline_max = np.sqrt( (np.abs(self.det.position[2]-self.source.position[2]) + self.det.height/2.)**2 + self.det.radius**2 )
        
        # neutrino mixing parameters:
        self.dm2 = dm2
        self.sin2theta_square = sin2theta_square

        # expected un-oscillated neutrino number:
        #self.source.scale_counts(self.det.height. self.det.volume, self.det.baseline, self.det.run_time )
        self.n_events = self.scale_counts()


    def scale_counts(self):
        # Scale the number of neutrinos generated by the source from the LZ paper (JHEP11(2014) 042)
        # Approximately take the average arrived neutrinos scaled by the square of distances from the source to the detector center (L+H/2.)**2
        # The LZ detector is hard-coded here.
        #H0 = 1.38 # unit: m, LZ detector height
        #R0 = H0 / 2. # unit: m, LZ detector radius
        #V0 = np.pi * R0**2 * H0 # unit: m^3, LZ detector volume
        #L0 = 1 # unit: m, below the fiducial volume, along the central axis of the cylinder. Distance from the source to the bottom plane of the cylinder.
        
        N0 = 12518 # 100 days run
        T0 = 100 # unit: days, 100 days run
        activity0 = 5e6 # unit: Ci, 1 Ci = 3.7e10 dacays per second
        geometry_factor_LZ =  0.775229 # hard-coded, I did convolve_oscillation_event_rate for LZ detector without oscillation
        
        #H = self.det.height
        #V = self.det.volume
        #L = self.det.baseline - self.det.height/2.
        #L = np.sqrt((self.source.position[0]-self.det.position[0])**2 + (self.source.position[1]-self.det.position[1])**2 + (self.source.position[2]-self.det.position[2])**2 ) - self.det.height/2.
        T = self.det.run_time
        
        Enu = self.source.energies[0]
        geometry_factor = self.convolve_oscillation_event_rate(Enu)[0]
        br  = self.source.ratios[0]
        xsec_nue = self.xsec.total_xsec_nuescatter(Enu)
        xsec_cc = self.xsec.total_xsec_CC(Enu)

        totxsec = 0.
        if self.interaction == 'nue':
            totxsec = xsec_nue
        elif self.interaction == 'CC':
            totxsec = xsec_cc
        else:
            print("There is no such interaction in this package -> must in {'CC', 'nue'}.")

        self.n_events = N0 * (T/T0) * (geometry_factor/geometry_factor_LZ) * (self.source.activity/activity0) * br * (totxsec/xsec_nue)
        #self.n_events = (N0 / V0 / T0 * (L0+ H0/2.)**2 ) * V * T / (L+H/2.)**2 * (self.source.activity / activity0) * br * totxsec / xsec_nue
        return self.n_events
    
    ## getter methods:

    def _get_source(self):
        return self.gen
    
    def _get_detector(self):
        return self.det
    
    def _get_nevents(self):
        return self.n_events
    
    def _get_baseline_range(self):
        return self.baseline_min, self.baseline_max

    def _get_oscillation_length(self):
        return oscillation_length(self.dm2, self.source.energies[0])

    ### setter methods:
    def _set_dm2(self, dm2):
        self.dm2 = dm2
        
    def _set_sin2theta_square(self, sin2):
        self.sin2theta_square = sin2


    ####################################
    ### Generating events uniformly in the detector, which could be incorrect because I did not consider the flux scaling in unit volumes with different distances.

    def generate_in_cubic(self, x0, y0, z0, H0, L0, N0):
        x = np.random.uniform(-L0/2+x0, L0/2+x0, size=N0)
        y = np.random.uniform(-L0/2+y0, L0/2+y0, size=N0)
        z = np.random.uniform(-H0/2+z0, H0/2+z0, size=N0)
        return x, y, z
    
    def Is_in_detector(self, x, y, z):
        if ( np.sqrt((x-self.det.position[0])**2 + (y-self.det.position[1])**2) < self.det.radius) and (-self.det.height/2. <= z-self.det.position[2] < self.det.height/2.) :
            return True
        else:
            return False

    def smear_position(self, pos, res):
        x_smeared = np.random.normal(loc=pos[:,0], scale=res, size=len(pos))
        y_smeared = np.random.normal(loc=pos[:,1], scale=res, size=len(pos))
        z_smeared = np.random.normal(loc=pos[:,2], scale=res, size=len(pos))
        pos_smeared = np.array([x_smeared, y_smeared, z_smeared]).T
        bl = np.sqrt( (x_smeared - self.source.position[0])**2 + (y_smeared - self.source.position[1])**2 + (z_smeared - self.source.position[2])**2 )
        return pos_smeared, bl


    def generate_nonoscillate_Asimov_dataset(self, smear=False):
        nu_pos = []
        bl = []
        n_event0 = int(2 * self.n_events) # Hard-coded as 2-fold to make sure we generate enough samples first in the cubic volume.
        x0, y0, z0 = self.generate_in_cubic(*self.det.position, self.det.height, 2*self.det.radius, n_event0)
        for x, y, z in zip(x0, y0, z0) :
            if self.Is_in_detector(x, y, z):
                #nu_pos.append( (x, y, z) )
                tmp_bl = np.sqrt((x - self.source.position[0])**2 + (y - self.source.position[1])**2 + (z - self.source.position[2])**2) 
                flux_scale = (self.baseline_min)**2 / tmp_bl**2
            else:
                continue
        if not smear:
            return np.array(nu_pos[0:int(self.n_events)]), np.array(bl[0:int(self.n_events)])
        else:
            pos_smeared, bl_smeared = self.smear_position(np.array(nu_pos[0:int(self.n_events)]), self.det.spatial_resolution)
            return pos_smeared, bl_smeared
        
        
        
    def generate_oscillate_Asimov_dataset(self, Enu, smear=False):
        nu_pos0, bl0 = self.generate_nonoscillate_Asimov_dataset()
        sur_p = electron_neutrino_survival_probability(self.dm2, self.sin2theta_square, Enu, bl0)
        flux_scale = self.baseline_min**2 / bl0**2 
        p0 = np.random.uniform(0, 1, size=len(sur_p))
        sur_id = np.where(p0 < sur_p * flux_scale)[0]
        nu_pos, bl = [], []
        for id in sur_id:
            nu_pos.append( nu_pos0[id] ) 
            bl.append(bl0[id])
        
        if not smear:
            return np.array(nu_pos), np.array(bl)
        else:
            pos_smeared, bl_smeared = self.smear_position(np.array(nu_pos), self.det.spatial_resolution)
            return pos_smeared, bl_smeared
    
    
    # Do numerical integral to as: int_V (Phi) dV \propto int_V (P(V)/L^2) dV (where P is the survival probability, L is the distance) 
    # Considering flux scaling at each unit volume, and also the survival probability 
    def expected_rate_oneCylindricalLayer(self, r, z, E):
        bl = np.sqrt(r**2 + (z - self.source.position[2])**2) 
        P = electron_neutrino_survival_probability(self.dm2, self.sin2theta_square, E, bl)
        return 2*np.pi * r * P / bl**2


    def convolve_oscillation_event_rate(self, E):
        f = lambda r, z, E: self.expected_rate_oneCylindricalLayer(r, z, E)
        res, err = dblquad(f, -self.det.height/2., self.det.height/2., lambda z: 0., lambda z: self.det.radius, args=(E, ), )
        return res, err



    def fill_rateVSbaseline_histogram(self, E, step_bl=0.03):
        # A tiny volume: dV = r dr dtheta dz
        N_bl = int((self.baseline_max - self.baseline_min) / step_bl) + 1
        bl_edges = np.array([self.baseline_min + step_bl*i for i in range(N_bl+1)])
        bl_cents = ( bl_edges[1:] + bl_edges[:-1]) / 2.
        bl_cents = np.zeros(N_bl)
        step_z = 0.001 # m
        step_r = 0.001 # m
        for z in np.arange(-self.det.height/2., self.det.height/2., step_z):
            for r in np.arange(0, self.det.radius, step_r):
                    dV = r * step_r * step_z  * 2*np.pi
                    tmp_rate = self.expected_rate_oneCylindricalLayer(r, z, E) * dV
                    tmp_bl = np.sqrt(r**2 + (z - self.source.position[2])**2) 
                    bl_idx = int((tmp_bl-self.baseline_min) / step_bl)
                    bl_cents[bl_idx] += tmp_rate
        return bl_edges, bl_cents
                    

        
            